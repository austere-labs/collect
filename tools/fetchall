#!/bin/bash

# GitHub repository details
REPO="austere-labs/collect"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default options
FORCE_OVERWRITE=false

# Function to print colored output
print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${YELLOW}→${NC} $1"
}

print_header() {
    echo -e "${BLUE}═══════════════════════════════════════════${NC}"
    echo -e "${BLUE}  GitHub Fetch All Tool${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════${NC}"
}

# Function to show usage
show_usage() {
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --force    Overwrite existing files"
    echo "  --help     Show this help message"
    echo "  --llm      Show LLM-formatted usage"
    echo ""
    echo "This script downloads multiple resources from:"
    echo "  https://github.com/$REPO"
    echo ""
    echo "Resources downloaded:"
    echo "  - movetools script (if available)"
    echo "  - All scripts from /tools/*"
    echo "  - All .md files from /.claude/commands/*"
    echo "  - All .md files from /.gemini/commands/*"
    echo "  - All .md files from /guides/*"
    echo ""
    echo "Additional actions:"
    echo "  - If .gemini/commands/ doesn't exist in repo, copies from .claude/commands/"
    echo ""
    exit 0
}

# Function to show LLM-formatted usage
show_llm_usage() {
    echo "# fetchall Usage Guide"
    echo ""
    echo "This script downloads multiple resources from the austere-labs/collect GitHub repository."
    echo "If run from a 'tools' subdirectory, it will place files in the parent project directory."
    echo ""
    echo "## Usage"
    echo "\`\`\`bash"
    echo "./fetchall [options]"
    echo "\`\`\`"
    echo ""
    echo "## Options"
    echo "- \`--force\` - Overwrite existing files in the destination directories"
    echo "- \`--help\` - Show basic usage information"
    echo "- \`--llm\` - Show this LLM-formatted usage guide"
    echo ""
    echo "## Repository Details"
    echo "- **Source Repository**: https://github.com/$REPO"
    echo "- **Resources Downloaded**:"
    echo "  - \`movetools\` - Single script file saved to ./movetools (if available)"
    echo "  - \`tools/*\` - All scripts from /tools/ directory"
    echo "  - \`.claude/commands/*.md\` - All command template files (recursive)"
    echo "  - \`.gemini/commands/*.md\` - All Gemini command template files (recursive)"
    echo "  - \`guides/*.md\` - All guide markdown files"
    echo ""
    echo "## Local Directory Structure Created"
    echo "\`\`\`"
    echo "./movetools           # Single script file (if available)"
    echo "./tools/              # Scripts from /tools/*"
    echo "./.claude/commands/   # Command templates (*.md)"
    echo "./.gemini/commands/   # Gemini command templates (*.md)"
    echo "./guides/             # Guide files (*.md)"
    echo "\`\`\`"
    echo ""
    echo "Note: When run from tools/ directory, files are placed in the parent directory."
    echo ""
    echo "## Examples"
    echo "\`\`\`bash"
    echo "# Download all resources (skip existing)"
    echo "./fetchall"
    echo ""
    echo "# Download and overwrite existing files"
    echo "./fetchall --force"
    echo ""
    echo "# Show help information"
    echo "./fetchall --help"
    echo "\`\`\`"
    echo ""
    echo "## Features"
    echo "- Downloads multiple resource types in one execution"
    echo "- Creates necessary directories automatically"
    echo "- Preserves directory structure for commands"
    echo "- Downloads .gemini/commands if available, otherwise copies from .claude/commands"
    echo "- Sets executable permissions for script files"
    echo "- Shows progress for each file downloaded"
    echo "- Provides category-based summary"
    echo "- Skips existing files by default (use --force to overwrite)"
    echo "- Uses GitHub CLI (gh) for secure API access"
    echo ""
    echo "## Requirements"
    echo "- GitHub CLI (\`gh\`) must be installed and authenticated"
    echo "- \`jq\` command-line JSON processor"
    echo "- \`base64\` command for content decoding"
    echo ""
    echo "## Error Handling"
    echo "The script handles common errors gracefully:"
    echo "- Missing GitHub CLI installation"
    echo "- Network connectivity issues"
    echo "- Repository access problems"
    echo "- File system permission errors"
    echo "- Continues with other categories if one fails"
    exit 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --force)
            FORCE_OVERWRITE=true
            shift
            ;;
        --help)
            show_usage
            ;;
        --llm)
            show_llm_usage
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

print_header
echo ""

# Check if gh CLI is installed
if ! command -v gh &> /dev/null; then
    print_error "GitHub CLI (gh) is not installed"
    echo "Please install it from: https://cli.github.com/"
    exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    print_error "jq is not installed"
    echo "Please install jq from: https://stedolan.github.io/jq/download/"
    exit 1
fi

# Create temp file for tracking stats
STATS_FILE=$(mktemp)
echo "0 0 0 0 0 0 0 0 0 0 0 0" > "$STATS_FILE"

# Determine the base directory
# If we're in a 'tools' subdirectory, use the parent directory
# Otherwise use the current directory
BASE_DIR="."
if [ "$(basename "$PWD")" = "tools" ] && [ -d "../.git" -o -f "../pyproject.toml" -o -f "../main.py" ]; then
    BASE_DIR=".."
    print_info "Detected execution from tools/ directory, using parent directory"
fi

# Create directories if they don't exist
print_info "Creating necessary directories..."
DIRS_TO_CREATE=("$BASE_DIR/tools" "$BASE_DIR/.claude/commands" "$BASE_DIR/.gemini/commands" "$BASE_DIR/guides")

for dir in "${DIRS_TO_CREATE[@]}"; do
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
        if [ $? -ne 0 ]; then
            print_error "Failed to create directory: $dir"
            rm -f "$STATS_FILE"
            exit 1
        fi
        print_success "Created $dir"
    fi
done

echo ""

# Function to update stats
update_stats() {
    local category="$1"
    local action="$2"  # downloaded, skipped, or failed
    
    # Read current stats
    read d_mt s_mt f_mt d_t s_t f_t d_c s_c f_c d_g s_g f_g < "$STATS_FILE"
    
    # Update the appropriate counter
    case "$category" in
        movetools)
            case "$action" in
                downloaded) ((d_mt++)) ;;
                skipped) ((s_mt++)) ;;
                failed) ((f_mt++)) ;;
            esac
            ;;
        tools)
            case "$action" in
                downloaded) ((d_t++)) ;;
                skipped) ((s_t++)) ;;
                failed) ((f_t++)) ;;
            esac
            ;;
        commands)
            case "$action" in
                downloaded) ((d_c++)) ;;
                skipped) ((s_c++)) ;;
                failed) ((f_c++)) ;;
            esac
            ;;
        guides)
            case "$action" in
                downloaded) ((d_g++)) ;;
                skipped) ((s_g++)) ;;
                failed) ((f_g++)) ;;
            esac
            ;;
    esac
    
    # Write updated stats
    echo "$d_mt $s_mt $f_mt $d_t $s_t $f_t $d_c $s_c $f_c $d_g $s_g $f_g" > "$STATS_FILE"
}

# Function to download a file
download_file() {
    local remote_path="$1"
    local local_path="$2"
    local is_executable="$3"
    local category="$4"
    
    # Check if file exists and handle accordingly
    if [ -f "$local_path" ] && [ "$FORCE_OVERWRITE" = false ]; then
        echo -n "  $local_path (exists, skipping)... "
        echo -e "${YELLOW}→${NC}"
        update_stats "$category" "skipped"
        return 0
    fi
    
    if [ -f "$local_path" ]; then
        echo -n "  $local_path (overwriting)... "
    else
        echo -n "  $local_path... "
    fi
    
    # Download the file using gh api
    CONTENT=$(gh api repos/$REPO/contents/$remote_path --jq '.content' 2>/dev/null)
    
    if [ $? -eq 0 ] && [ -n "$CONTENT" ]; then
        # Decode base64 content and save to file
        # First try GNU base64 (common on Linux and macOS with coreutils)
        if echo "$CONTENT" | base64 -d > "$local_path" 2>/dev/null; then
            :  # Success, do nothing
        # If that fails, try macOS native base64
        elif echo "$CONTENT" | base64 -D > "$local_path" 2>/dev/null; then
            :  # Success, do nothing
        else
            # Both failed
            false
        fi
        
        if [ $? -eq 0 ]; then
            # Set executable permissions if needed
            if [ "$is_executable" = true ]; then
                chmod +x "$local_path"
            fi
            echo -e "${GREEN}✓${NC}"
            update_stats "$category" "downloaded"
            return 0
        else
            echo -e "${RED}✗${NC} (decode error)"
            update_stats "$category" "failed"
            return 1
        fi
    else
        echo -e "${RED}✗${NC} (download error)"
        update_stats "$category" "failed"
        return 1
    fi
}

# Function to process a directory recursively for .md files
process_md_directory() {
    local path="$1"
    local local_path="$2"
    local category="$3"
    
    # Get contents of current directory
    local contents=$(gh api repos/$REPO/contents/$path 2>/dev/null)
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch contents from $path"
        return 1
    fi
    
    # Process each item
    echo "$contents" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "dir" ]; then
            # Create local directory if it doesn't exist
            new_local_path="$local_path/$name"
            if [ ! -d "$new_local_path" ]; then
                mkdir -p "$new_local_path"
            fi
            # Recursively process subdirectory
            process_md_directory "$path/$name" "$new_local_path" "$category"
        elif [ "$type" = "file" ] && [[ "$name" == *.md ]]; then
            # Download the .md file
            download_file "$path/$name" "$local_path/$name" false "$category"
        fi
    done
}

# 1. Download movetools (if it exists in the repository)
print_info "Fetching movetools..."
# First check if movetools exists in the repository
MOVETOOLS_CHECK=$(gh api repos/$REPO/contents/movetools 2>/dev/null)
if [ $? -eq 0 ]; then
    download_file "movetools" "$BASE_DIR/movetools" true "movetools"
else
    print_info "movetools not found in repository, skipping..."
fi

echo ""

# 2. Download tools/*
print_info "Fetching tools..."
TOOLS_CONTENTS=$(gh api repos/$REPO/contents/tools 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$TOOLS_CONTENTS" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "file" ]; then
            download_file "tools/$name" "$BASE_DIR/tools/$name" true "tools"
        fi
    done
else
    print_error "Failed to fetch tools directory"
fi

echo ""

# 3. Download .claude/commands/*.md
print_info "Fetching .claude/commands..."
process_md_directory ".claude/commands" "$BASE_DIR/.claude/commands" "commands"

# 4. Download .gemini/commands/*.md (if it exists in the repo)
print_info "Checking for .gemini/commands in repository..."
GEMINI_CHECK=$(gh api repos/$REPO/contents/.gemini/commands 2>/dev/null)
if [ $? -eq 0 ]; then
    print_info "Found .gemini/commands in repository, downloading..."
    process_md_directory ".gemini/commands" "$BASE_DIR/.gemini/commands" "commands"
else
    print_info ".gemini/commands not found in repository, will copy from .claude/commands..."
fi

# Check if .gemini/commands has any files, if not copy from .claude/commands
GEMINI_FILE_COUNT=$(find "$BASE_DIR/.gemini/commands" -name "*.md" -type f 2>/dev/null | wc -l)
if [ "$GEMINI_FILE_COUNT" -eq 0 ]; then
    print_info "Copying .claude/commands/*.md to .gemini/commands..."
    if [ -d "$BASE_DIR/.claude/commands" ]; then
        # Find all .md files in .claude/commands (including subdirectories) and copy them
        find "$BASE_DIR/.claude/commands" -name "*.md" -type f | while IFS= read -r file; do
            # Get the relative path from .claude/commands
            relative_path="${file#$BASE_DIR/.claude/commands/}"
            target_file="$BASE_DIR/.gemini/commands/$relative_path"
            target_dir=$(dirname "$target_file")
            
            # Create target directory if it doesn't exist
            if [ ! -d "$target_dir" ]; then
                mkdir -p "$target_dir"
            fi
            
            # Copy the file
            cp "$file" "$target_file"
            if [ $? -eq 0 ]; then
                echo -n "  $target_file... "
                echo -e "${GREEN}✓${NC}"
            else
                echo -n "  $target_file... "
                echo -e "${RED}✗${NC}"
            fi
        done
    else
        print_error "No .claude/commands directory found to copy from"
    fi
fi

echo ""

# 5. Download guides/*.md
print_info "Fetching guides..."
GUIDES_CONTENTS=$(gh api repos/$REPO/contents/guides 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$GUIDES_CONTENTS" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "file" ] && [[ "$name" == *.md ]]; then
            download_file "guides/$name" "$BASE_DIR/guides/$name" false "guides"
        fi
    done
else
    print_error "Failed to fetch guides directory"
fi

# Print summary
echo ""
print_header
echo "Summary:"
echo ""

# Read final stats
read d_mt s_mt f_mt d_t s_t f_t d_c s_c f_c d_g s_g f_g < "$STATS_FILE"

# Calculate totals
TOTAL_DOWNLOADED=$((d_mt + d_t + d_c + d_g))
TOTAL_SKIPPED=$((s_mt + s_t + s_c + s_g))
TOTAL_FAILED=$((f_mt + f_t + f_c + f_g))

# Print category summaries
for category in movetools tools commands guides; do
    case "$category" in
        movetools) d=$d_mt; s=$s_mt; f=$f_mt ;;
        tools) d=$d_t; s=$s_t; f=$f_t ;;
        commands) d=$d_c; s=$s_c; f=$f_c ;;
        guides) d=$d_g; s=$s_g; f=$f_g ;;
    esac
    
    if [ $d -gt 0 ] || [ $s -gt 0 ] || [ $f -gt 0 ]; then
        echo -n "$category: "
        
        if [ $d -gt 0 ]; then
            echo -n -e "${GREEN}${d} downloaded${NC}"
        fi
        
        if [ $s -gt 0 ]; then
            [ $d -gt 0 ] && echo -n ", "
            echo -n -e "${YELLOW}${s} skipped${NC}"
        fi
        
        if [ $f -gt 0 ]; then
            [ $d -gt 0 ] || [ $s -gt 0 ] && echo -n ", "
            echo -n -e "${RED}${f} failed${NC}"
        fi
        
        echo ""
    fi
done

echo ""
echo "Total:"
print_success "$TOTAL_DOWNLOADED files downloaded successfully"

if [ $TOTAL_SKIPPED -gt 0 ]; then
    print_info "$TOTAL_SKIPPED files skipped (already exist)"
fi

if [ $TOTAL_FAILED -gt 0 ]; then
    print_error "$TOTAL_FAILED files failed to download"
fi

# Clean up
rm -f "$STATS_FILE"

echo ""
if [ $TOTAL_DOWNLOADED -gt 0 ] || [ $TOTAL_SKIPPED -gt 0 ]; then
    print_success "Resources available in current directory"
else
    print_error "No files were downloaded"
    exit 1
fi
