#!/usr/bin/env python3
"""
Build Source XML Tool (buildsrc)

Creates a source.xml file containing all project files, respecting .gitignore patterns
and excluding specified directories. Automatically detects project root via git repository.

Usage:
    buildsrc [--output OUTPUT] [--dry-run] [--verbose]
"""

import argparse
import os
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Iterator, Tuple, Optional, List, Dict
import pathspec
import sys
import subprocess
import time
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor, as_completed
from rich.console import Console
from rich.text import Text
from rich.panel import Panel
from rich.table import Table
from rich.syntax import Syntax
from rich.progress import Progress, TaskID
from rich import box


@dataclass
class ProcessingStats:
    """Statistics for file processing."""
    files_processed: int = 0
    files_skipped: int = 0
    total_size: int = 0
    directories_excluded: int = 0
    skipped_files: list = None

    def __post_init__(self):
        if self.skipped_files is None:
            self.skipped_files = []


class ColorfulHelpFormatter(argparse.HelpFormatter):
    """Custom help formatter that uses Rich for colorful output."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.console = Console()

    def format_help(self):
        """Format help message with rich formatting."""
        # Create the main help display
        self._show_colorful_help()
        return ""  # Return empty string since we've already printed

    def _show_colorful_help(self):
        """Display the colorful help menu."""
        console = Console()

        # Header
        title = Text("üî® Build Source XML & Directory Tree",
                     style="bold bright_blue")
        subtitle = Text(
            "Generate XML file with source code or directory tree structure", style="italic cyan")

        header_panel = Panel.fit(
            Text.assemble(title, "\n", subtitle),
            border_style="bright_blue",
            padding=(1, 2)
        )
        console.print("\n")
        console.print(header_panel)

        # Description
        description = Panel(
            Text.assemble(
                "This script can either read all project files (respecting .gitignore patterns) and\n",
                "concatenate them into a single XML document, or generate a directory tree structure.\n\n",
                Text("üìÑ XML Mode:", style="bold blue"),
                " Creates source.xml with all source code\n",
                Text("üå≥ Tree Mode:", style="bold green"),
                " Creates dir_structure.md with directory structure\n\n",
                Text("üö´ Automatically excludes:", style="bold red"),
                "\n  ‚Ä¢ data/ directory",
                "\n  ‚Ä¢ .claude/commands directory",
                "\n  ‚Ä¢ .gemini/commands directory",
                "\n  ‚Ä¢ tools/ directory",
                "\n  ‚Ä¢ guides/ directory",
                "\n  ‚Ä¢ resources/ directory",
                "\n  ‚Ä¢ dotfiles/ directory",
                "\n  ‚Ä¢ _progress/ directory",
                "\n  ‚Ä¢ _docs/ directory",
                "\n  ‚Ä¢ All .gitignore patterns",
                "\n  ‚Ä¢ Binary and cache files",
                "\n  ‚Ä¢ All markdown files (*.md)",
                "\n  ‚Ä¢ All JSON files (*.json)",
                "\n  ‚Ä¢ uv.lock, requirements.txt, .sync_cache.json"
            ),
            title="üìã Description",
            title_align="left",
            border_style="green",
            padding=(1, 2)
        )
        console.print(description)

        # Usage examples
        usage_table = Table(
            show_header=True,
            header_style="bold magenta",
            box=box.ROUNDED,
            title="üöÄ Usage Examples",
            title_style="bold cyan"
        )
        usage_table.add_column("Command", style="bright_green", no_wrap=True)
        usage_table.add_column("Description", style="white")

        usage_table.add_row(
            "buildsrc",
            "Generate source.xml with all project files"
        )
        usage_table.add_row(
            "buildsrc --dry-run",
            "Preview which files would be included (no output generated)"
        )
        usage_table.add_row(
            "buildsrc --verbose",
            "Show detailed processing information"
        )
        usage_table.add_row(
            "buildsrc -o custom.xml",
            "Generate XML with custom filename"
        )
        usage_table.add_row(
            "buildsrc --dry-run --verbose",
            "Preview files with detailed output"
        )
        usage_table.add_row(
            "buildsrc --tree",
            "Generate directory tree structure in dir_structure.md"
        )
        usage_table.add_row(
            "buildsrc --tree --dry-run",
            "Preview tree generation without creating output"
        )
        usage_table.add_row(
            "buildsrc --with-descriptions",
            "Generate XML with AI-powered file descriptions"
        )
        usage_table.add_row(
            "buildsrc --with-descriptions --verbose",
            "Generate descriptions with detailed progress output"
        )
        usage_table.add_row(
            "buildsrc --with-descriptions --parallel-workers 16",
            "Generate descriptions using 16 parallel workers for faster processing"
        )

        console.print(usage_table)

        # Options table
        options_table = Table(
            show_header=True,
            header_style="bold yellow",
            box=box.ROUNDED,
            title="‚öôÔ∏è  Command Options",
            title_style="bold cyan"
        )
        options_table.add_column("Option", style="bright_yellow", no_wrap=True)
        options_table.add_column("Description", style="white")
        options_table.add_column("Default", style="dim")

        options_table.add_row(
            "-o, --output FILE",
            "Specify output filename",
            "source.xml"
        )
        options_table.add_row(
            "--dry-run",
            "Show which files would be processed without creating output",
            "False"
        )
        options_table.add_row(
            "-v, --verbose",
            "Display detailed processing information",
            "False"
        )
        options_table.add_row(
            "-h, --help",
            "Show this colorful help message",
            ""
        )
        options_table.add_row(
            "--tree",
            "Generate directory tree structure instead of XML",
            "False"
        )
        options_table.add_row(
            "--with-descriptions",
            "Generate AI descriptions for each file using Claude",
            "False"
        )
        options_table.add_row(
            "--parallel-workers N",
            "Number of parallel workers for description generation",
            "8"
        )

        console.print(options_table)

        # XML structure example
        xml_example = '''<?xml version="1.0" encoding="UTF-8"?>
<source_code project="collect">
  <file path="collect.py">
    <description>
      ## Overview
      Main MCP server entry point that provides web fetching tools...
      ## Technical Details
      - Python 3+ with asyncio for async operations...
    </description>
    <content>
      #!/usr/bin/env python3
      import asyncio
      # ... file content ...
    </content>
  </file>
  <file path="models/anthropic_mcp.py">
    <description>
      ## Overview
      Anthropic Claude API integration wrapper...
    </description>
    <content>
      from typing import Dict, Any
      # ... file content ...
    </content>
  </file>
</source_code>'''

        xml_panel = Panel(
            Syntax(xml_example, "xml", theme="monokai", line_numbers=True),
            title="üìÑ Generated XML Structure (with --with-descriptions)",
            title_align="left",
            border_style="bright_magenta",
            padding=(1, 2)
        )
        console.print(xml_panel)

        # Footer
        footer_text = Text.assemble(
            "üí° ", ("Tip: ", "bold bright_yellow"),
            "Use --dry-run first to preview which files will be included!\n",
            "üéØ ", ("Output: ", "bold bright_green"),             "Creates well-formed XML with UTF-8 encoding\n",
            "‚ö° ", ("Performance: ", "bold bright_cyan"),
            "Processes large codebases efficiently with progress tracking"
        )

        footer_panel = Panel.fit(
            footer_text,
            border_style="bright_yellow",
            padding=(1, 2)
        )
        console.print(footer_panel)
        console.print("")


class GitignoreFilter:
    """Handles .gitignore pattern matching."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.spec = self._load_gitignore()

    def _load_gitignore(self) -> pathspec.PathSpec:
        """Load and parse .gitignore file."""
        gitignore_path = self.project_root / '.gitignore'
        patterns = []

        if gitignore_path.exists():
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                patterns = f.read().splitlines()

        return pathspec.PathSpec.from_lines('gitwildmatch', patterns)

    def should_ignore(self, path: Path) -> bool:
        """Check if path should be ignored according to gitignore rules."""
        relative_path = path.relative_to(self.project_root)
        return self.spec.match_file(str(relative_path))


class FileProcessor:
    """Processes individual files for XML generation."""

    def __init__(self, project_root: Path):
        self.project_root = project_root

    def is_text_file(self, file_path: Path) -> bool:
        """Check if file is likely a text file."""
        try:
            # Check file extension first
            text_extensions = {
                '.py', '.txt', '.yml', '.yaml', '.json', '.toml', '.ini',
                '.sql', '.sh', '.lua', '.js', '.ts', '.html', '.css', '.xml',
                '.cfg', '.conf', '.gitignore', '.env', '.lock'
            }

            if file_path.suffix.lower() in text_extensions:
                return True

            # For files without extension, try to read a small sample
            if not file_path.suffix:
                try:
                    with open(file_path, 'rb') as f:
                        sample = f.read(1024)
                        # Check if sample contains null bytes (binary indicator)
                        return b'\x00' not in sample
                except:
                    return False

            return False
        except:
            return False

    def read_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling."""
        encodings = ['utf-8', 'utf-8-sig', 'latin1', 'cp1252']

        for encoding in encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    return f.read()
            except (UnicodeDecodeError, UnicodeError):
                continue
            except Exception as e:
                return f"[ERROR: Could not read file - {str(e)}]"

        return "[ERROR: Could not decode file with any supported encoding]"

    def get_relative_path(self, file_path: Path) -> str:
        """Get relative path from project root."""
        return str(file_path.relative_to(self.project_root))


class SourceXMLBuilder:
    """Main class for building the source XML."""

    def __init__(self, project_root: Path, output_file: str = 'source.md'):
        self.project_root = project_root
        self.output_file = output_file
        self.gitignore_filter = GitignoreFilter(project_root)
        self.file_processor = FileProcessor(project_root)
        self.stats = ProcessingStats()

        # Directories to exclude
        self.excluded_dirs = {
            'data',
            '.claude/commands',
            '.gemini/commands',
            'tools',
            'guides',
            'resources',
            'dotfiles',
            '_progress',
            '__pycache__',
            '.pytest_cache',
            '.git',
            '.venv',
            'venv',
            'env',
            'htmlcov',
            'build',
            'dist',
            '*.egg-info'
        }

    def should_exclude_directory(self, dir_path: Path) -> bool:
        """Check if directory should be excluded."""
        relative_path = str(dir_path.relative_to(self.project_root))

        # Check exact matches
        if relative_path in self.excluded_dirs:
            return True

        # Check if any part of the path matches excluded directories
        path_parts = Path(relative_path).parts
        for part in path_parts:
            if part in self.excluded_dirs:
                return True

        # Check specific path patterns
        excluded_patterns = [
            'data',
            '.claude/commands',
            '.gemini/commands',
            'tools',
            'guides',
            'resources',
            'dotfiles',
            '_progress',
            '_docs'
        ]

        for pattern in excluded_patterns:
            if relative_path == pattern or relative_path.startswith(pattern + '/'):
                return True

        return False

    def collect_files(self) -> Iterator[Path]:
        """Collect all files that should be included in the XML."""
        for root, dirs, files in os.walk(self.project_root):
            root_path = Path(root)

            # Skip if current directory should be excluded
            if self.should_exclude_directory(root_path):
                self.stats.directories_excluded += 1
                dirs.clear()  # Don't recurse into this directory
                continue

            # Filter out excluded directories from further traversal
            dirs[:] = [
                d for d in dirs if not self.should_exclude_directory(root_path / d)]

            for file_name in files:
                file_path = root_path / file_name

                # Skip if file matches gitignore patterns
                if self.gitignore_filter.should_ignore(file_path):
                    self.stats.files_skipped += 1
                    rel_path = self.file_processor.get_relative_path(file_path)
                    self.stats.skipped_files.append(
                        (rel_path, "gitignore pattern"))
                    continue

                # Skip specific files, markdown files, and JSON files
                excluded_files = {'uv.lock',
                                  'requirements.txt', '.sync_cache.json'}
                if file_name in excluded_files or file_name.endswith('.md') or file_name.endswith('.json'):
                    self.stats.files_skipped += 1
                    rel_path = self.file_processor.get_relative_path(file_path)
                    if file_name.endswith('.md'):
                        reason = "markdown file"
                    elif file_name.endswith('.json'):
                        reason = "JSON file"
                    else:
                        reason = "excluded file"
                    self.stats.skipped_files.append(
                        (rel_path, reason))
                    continue

                # Skip if not a text file
                if not self.file_processor.is_text_file(file_path):
                    self.stats.files_skipped += 1
                    rel_path = self.file_processor.get_relative_path(file_path)
                    self.stats.skipped_files.append(
                        (rel_path, "binary/non-text file"))
                    continue

                yield file_path

    def build_xml(self, dry_run: bool = False, verbose: bool = False, with_descriptions: bool = False, parallel_workers: int = 8) -> str:
        """Build the XML content."""
        if verbose:
            print(f"Scanning project: {self.project_root}")

        # Create root element
        root = ET.Element('source_code')
        root.set('project', str(self.project_root.name))

        files_to_process = list(self.collect_files())

        if dry_run:
            print(f"Would process {len(files_to_process)} files:")
            for file_path in files_to_process:
                rel_path = self.file_processor.get_relative_path(file_path)
                print(f"  - {rel_path}")
            return ""

        # Collect all file data first
        if verbose:
            print(f"Reading {len(files_to_process)} files...")

        file_data = []
        for file_path in files_to_process:
            if verbose:
                rel_path = self.file_processor.get_relative_path(file_path)
                print(f"Reading: {rel_path}")

            content = self.file_processor.read_file_content(file_path)
            file_data.append((file_path, content))

            self.stats.files_processed += 1
            self.stats.total_size += len(content)

        # Generate descriptions in parallel if requested
        descriptions = {}
        if with_descriptions and file_data:
            descriptions = self.generate_descriptions_parallel(
                file_data,
                workers=parallel_workers,
                verbose=verbose
            )

        # Build XML tree
        if verbose:
            print("Building XML tree...")

        for file_path, content in file_data:
            # Create file element
            file_element = ET.SubElement(root, 'file')
            rel_path = self.file_processor.get_relative_path(file_path)
            file_element.set('path', rel_path)

            # Add description if available
            if with_descriptions and file_path in descriptions:
                description_element = ET.SubElement(
                    file_element, 'description')
                description_element.text = descriptions[file_path]

            # Add file content
            content_element = ET.SubElement(file_element, 'content')
            content_element.text = content

        # Create XML string
        ET.indent(root, space="  ", level=0)
        xml_str = ET.tostring(root, encoding='unicode', xml_declaration=True)

        return xml_str

    def create_description(self, file: str) -> str:
        description_instruction_prompt = f"""
        Analyze the provided code and create a concise description.
        Keep it brief and focused on the essentials.

        Provide:
        - What this code does (3-4 sentences)
        - Key functions/classes and their purpose
        - Main technologies/frameworks used
        - Notable implementation details (if any)

        Keep the response under 200 words. Use clear, technical language.

        [CODE TO ANALYZE]:
        {file}
        """

        GEMINI_MODEL = "gemini-2.5-flash"

        result = subprocess.run(
            ["gemini",
             "--model",
             GEMINI_MODEL,
             "--prompt",
             description_instruction_prompt],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()

    def generate_descriptions_parallel(
        self,
        file_data: List[Tuple[Path, str]],
        workers: int = 8,
        verbose: bool = False
    ) -> Dict[Path, str]:
        """Generate descriptions for multiple files in parallel."""
        if not file_data:
            return {}

        descriptions = {}

        if verbose:
            print(f"Generating descriptions for {
                  len(file_data)} files using {workers} parallel workers...")

        # Create a rich progress bar
        with Progress() as progress:
            task = progress.add_task(
                "Generating descriptions...", total=len(file_data))

            with ThreadPoolExecutor(max_workers=workers) as executor:
                # Submit all tasks
                future_to_file = {
                    executor.submit(self.create_description, content): (path, content)
                    for path, content in file_data
                }

                # Process completed tasks
                for future in as_completed(future_to_file):
                    path, content = future_to_file[future]
                    rel_path = self.file_processor.get_relative_path(path)

                    try:
                        # 60 second timeout per file
                        description = future.result(timeout=60)
                        descriptions[path] = description
                        if verbose:
                            print(f"  ‚úÖ Generated description for: {rel_path}")
                    except Exception as e:
                        descriptions[path] = "[Description generation failed]"
                        if verbose:
                            print(f"  ‚ùå Failed to generate description for {
                                  rel_path}: {e}")

                    progress.update(task, advance=1)

        successful = sum(1 for desc in descriptions.values()
                         if desc != "[Description generation failed]")
        if verbose:
            print(f"Description generation complete: {
                  successful}/{len(file_data)} successful")

        return descriptions

    def write_xml(self, xml_content: str) -> None:
        """Write XML content to file."""
        output_path = self.project_root / self.output_file

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(xml_content)

        console = Console()

        # Success message with file info
        file_size_kb = len(xml_content) / 1024
        success_text = Text.assemble(
            "‚úÖ ", ("Success! ", "bold bright_green"),
            "XML file generated successfully\n\n",
            "üìÑ ", ("File: ", "bold bright_blue"), f"{output_path}\n",
            "üìä ", ("Size: ", "bold bright_cyan"), f"{file_size_kb:.1f} KB ({len(xml_content):,} characters)")

        success_panel = Panel.fit(
            success_text,
            title="üéâ Build Complete",
            title_align="left",
            border_style="bright_green",
            padding=(1, 2)
        )

        console.print(success_panel)

    def print_stats(self) -> None:
        """Print processing statistics."""
        console = Console()

        # Create statistics table
        stats_table = Table(
            show_header=True,
            header_style="bold magenta",
            box=box.ROUNDED,
            title="üìà Processing Statistics",
            title_style="bold bright_yellow"
        )

        stats_table.add_column("Metric", style="bright_cyan", no_wrap=True)
        stats_table.add_column("Count", style="bright_green", justify="right")
        stats_table.add_column("Details", style="dim white")

        # Add rows with emojis and formatting
        stats_table.add_row(
            "‚úÖ Files Processed",
            f"{self.stats.files_processed:,}",
            "Successfully included in XML"
        )

        stats_table.add_row(
            "‚è≠  Files Skipped",
            f"{self.stats.files_skipped:,}",
            "Binary files, gitignore matches"
        )

        stats_table.add_row(
            "üö´ Directories Excluded",             f"{
                self.stats.directories_excluded:,}",
            "Matched exclusion patterns"
        )

        # Format content size with appropriate units
        size_mb = self.stats.total_size / (1024 * 1024)
        if size_mb >= 1:
            size_display = f"{size_mb:.1f} MB"
        else:
            size_kb = self.stats.total_size / 1024
            size_display = f"{size_kb:.1f} KB"

        stats_table.add_row(
            "üìä Total Content",             f"{self.stats.total_size:,}",
            f"{size_display} of source code"
        )

        console.print("")  # Add some spacing
        console.print(stats_table)

        # Show skipped files if any
        if self.stats.skipped_files:
            console.print("")  # Add spacing

            skipped_table = Table(
                show_header=True,
                header_style="bold red",
                box=box.ROUNDED,
                title="‚ö†Ô∏è  Skipped Files",
                title_style="bold bright_red"
            )

            skipped_table.add_column("File", style="dim white", no_wrap=False)
            skipped_table.add_column(
                "Reason", style="bright_red", justify="left")

            # Group by reason for better display
            by_reason = {}
            for file_path, reason in self.stats.skipped_files:
                if reason not in by_reason:
                    by_reason[reason] = []
                by_reason[reason].append(file_path)

            # Add rows grouped by reason
            for reason, files in by_reason.items():
                for i, file_path in enumerate(files):
                    if i == 0:
                        skipped_table.add_row(file_path, reason)
                    else:
                        skipped_table.add_row(file_path, "")

                # Add separator between different reasons
                if reason != list(by_reason.keys())[-1]:
                    skipped_table.add_row("", "")

            console.print(skipped_table)


class TreeGenerator:
    """Generates directory tree structure using tree command with gitignore filtering."""

    def __init__(self, project_root: Path, output_file: str = 'dir_structure.md'):
        self.project_root = project_root
        self.output_file = output_file
        self.gitignore_filter = GitignoreFilter(project_root)

        # Directories to exclude (same as SourceXMLBuilder)
        self.excluded_dirs = {
            'data',
            '.claude/commands',
            '.gemini/commands',
            'tools',
            'guides',
            'resources',
            'dotfiles',
            '_progress',
            '__pycache__',
            '.pytest_cache',
            '.git',
            '.venv',
            'venv',
            'env',
            'htmlcov',
            'build',
            'dist',
            '*.egg-info',
            '_docs'
        }

    def _create_tree_ignore_file(self) -> Path:
        """Create a temporary ignore file for tree command."""
        ignore_file = self.project_root / '.treeignore'

        # Get gitignore patterns
        gitignore_path = self.project_root / '.gitignore'
        patterns = []

        if gitignore_path.exists():
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                patterns = f.read().splitlines()

        # Add our excluded directories
        patterns.extend(self.excluded_dirs)

        # Write to temporary ignore file
        with open(ignore_file, 'w', encoding='utf-8') as f:
            for pattern in patterns:
                if pattern.strip() and not pattern.startswith('#'):
                    f.write(pattern + '\n')

        return ignore_file

    def generate_tree(self, dry_run: bool = False) -> str:
        """Generate directory tree structure."""
        console = Console()

        if dry_run:
            console.print("Would generate directory tree in dir_structure.md")
            return ""

        # Create temporary ignore file
        ignore_file = self._create_tree_ignore_file()

        try:
            # Run tree command with ignore file
            cmd = [
                'tree',
                str(self.project_root),
                '-I', '|'.join(self.excluded_dirs),
                '--gitignore'
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=self.project_root
            )

            if result.returncode != 0:
                console.print(f"[red]Error running tree command: {
                              result.stderr}[/red]")
                return ""

            tree_output = result.stdout

            # Write to markdown file
            output_path = self.project_root / self.output_file
            markdown_content = f"# Directory Structure\n\n```\n{
                tree_output}```\n"

            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)

            # Success message
            success_text = Text.assemble(
                "‚úÖ ", ("Success! ", "bold bright_green"),
                "Directory tree generated successfully\n\n",
                "üìÑ ", ("File: ", "bold bright_blue"), f"{output_path}\n",
                "üå≥ ", ("Content: ",
                       "bold bright_cyan"), "Directory structure with gitignore filtering")

            success_panel = Panel.fit(
                success_text,
                title="üå≥ Tree Complete",
                title_align="left",
                border_style="bright_green",
                padding=(1, 2)
            )

            console.print(success_panel)

            return markdown_content

        finally:
            # Clean up temporary ignore file
            if ignore_file.exists():
                ignore_file.unlink()


def find_project_root() -> Path:
    """Find the project root by looking for git repository or other markers."""
    current = Path.cwd().resolve()

    # Walk up the directory tree looking for .git directory
    while current != current.parent:
        if (current / '.git').exists():
            return current
        current = current.parent

    # If no .git found, fall back to current working directory
    return Path.cwd().resolve()


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Build source code XML file',
        formatter_class=ColorfulHelpFormatter,
        add_help=False  # We'll handle help ourselves
    )

    # Add help argument manually to control its behavior
    parser.add_argument('-h', '--help', action='help',
                        help='Show colorful help message and exit')

    parser.add_argument('--output', '-o', default='source.md',
                        metavar='FILE',
                        help='Output file name (default: source.md)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show which files would be processed without creating output')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Verbose output showing file processing')
    parser.add_argument('--tree', action='store_true',
                        help='Generate directory tree structure instead of XML')
    parser.add_argument('--with-descriptions', action='store_true',
                        help='Generate AI descriptions for each file (slower but more informative)')
    parser.add_argument('--parallel-workers', type=int, default=8,
                        metavar='N',
                        help='Number of parallel workers for description generation (default: 8)')

    args = parser.parse_args()

    # Find project root by looking for git repository
    project_root = find_project_root()

    try:
        if args.tree:
            # Generate directory tree
            tree_generator = TreeGenerator(project_root, 'dir_structure.md')
            tree_generator.generate_tree(dry_run=args.dry_run)
        else:
            # Generate XML (default behavior)
            builder = SourceXMLBuilder(project_root, args.output)

            # Build XML
            xml_content = builder.build_xml(
                dry_run=args.dry_run, verbose=args.verbose, with_descriptions=args.with_descriptions, parallel_workers=args.parallel_workers)

            if not args.dry_run:
                # Write to file
                builder.write_xml(xml_content)

            # Print statistics
            builder.print_stats()

    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
