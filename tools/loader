#!/usr/bin/env python3
from enum import StrEnum
from pathlib import Path
import sys
import requests
from requests.exceptions import (
    RequestException,
    Timeout,
    ConnectionError,
    HTTPError
)
import logging
from datetime import datetime, timezone

logger = logging.getLogger(__name__)


def read_env_value(key: str) -> str:
    """Simple .env file reader to get a specific key"""
    project_dir = Path(__file__).parent.parent
    env_file = project_dir / ".env"

    if not env_file.exists():
        return ""

    try:
        with open(env_file, "r") as f:
            for line in f:
                line = line.strip()
                # Skip comments and empty lines
                if not line or line.startswith("#"):
                    continue
                # Parse KEY=VALUE format
                if "=" in line:
                    env_key, env_value = line.split("=", 1)
                    if env_key.strip() == key:
                        return env_value.strip()
    except Exception:
        pass

    return ""


def plans_check_dirs() -> bool:
    """Check if all required plan directories exist, create them if missing

    Returns:
        bool: True if all directories exist or were created successfully,
        False on error
    """
    project_dir = Path(__file__).parent.parent
    plans_dir = project_dir / "_docs" / "plans"

    # Required directories
    required_dirs = [
        plans_dir,
        plans_dir / "drafts",
        plans_dir / "approved",
        plans_dir / "completed",
    ]

    missing_dirs = []
    created_dirs = []

    for dir_path in required_dirs:
        if not dir_path.exists():
            missing_dirs.append(dir_path)

    if missing_dirs:
        print("üìÅ Creating missing plan directories:")
        for missing_dir in missing_dirs:
            try:
                missing_dir.mkdir(parents=True, exist_ok=True)
                created_dirs.append(missing_dir)
                print(
                    f"   ‚úÖ Created: {missing_dir.relative_to(project_dir)}"
                )
            except Exception as e:
                print(
                    f"   ‚ùå Failed to create {missing_dir.relative_to(project_dir)}: {
                        e}"
                )
                return False

        if created_dirs:
            print(
                f"üìÅ Successfully created {len(created_dirs)} directories"
            )
    else:
        print("‚úÖ All required plan directories exist")

    return True


def cmd_check_dirs() -> bool:
    """Check if all required command directories exist,
       create them if missing

    Returns:
        bool: True if all directories exist or were created successfully,
        False on error
    """
    project_dir = Path(__file__).parent.parent
    claude_dir = project_dir / ".claude"
    gemini_dir = project_dir / ".gemini"

    # Get subdirectories from .env config
    command_subdirs_str = read_env_value("COMMAND_SUBDIRS")
    if not command_subdirs_str:
        # Default subdirectories if not in .env
        command_subdirs_str = "archive,go,js,mcp,python,tools"

    # Parse comma-separated subdirectories
    subdirs = [s.strip() for s in command_subdirs_str.split(",")]

    # Build required directories
    required_dirs = {
        "claude": [claude_dir / "commands"]
        + [claude_dir / "commands" / subdir for subdir in subdirs],
        "gemini": [gemini_dir / "commands"]
        + [gemini_dir / "commands" / subdir for subdir in subdirs],
    }

    # Check for missing directories by type
    missing_by_type = {"claude": [], "gemini": []}
    for dir_type, dirs in required_dirs.items():
        for dir_path in dirs:
            if not dir_path.exists():
                missing_by_type[dir_type].append(dir_path)

    # Count total missing
    total_missing = sum(len(dirs) for dirs in missing_by_type.values())

    if total_missing == 0:
        print("‚úÖ All required command directories exist")
        return True

    # Create missing directories
    print(f"üìÅ Creating {total_missing} missing command directories:")
    created_count = 0
    failed = False

    for dir_type, missing_dirs in missing_by_type.items():
        if missing_dirs:
            print(f"\n   {dir_type.title()} directories:")
            for missing_dir in missing_dirs:
                try:
                    missing_dir.mkdir(parents=True, exist_ok=True)
                    created_count += 1
                    print(
                        f"   ‚úÖ Created: {missing_dir.relative_to(project_dir)}"
                    )
                except Exception as e:
                    print(
                        f"   ‚ùå Failed to create {missing_dir.relative_to(project_dir)}: {
                            e}"
                    )
                    failed = True

    if created_count > 0:
        print(f"\nüìÅ Successfully created {created_count} directories")

    return not failed


def load_plans_from_disk() -> dict:
    """Load all plan files from disk and return as JSON string"""
    project_dir = Path(__file__).parent.parent
    plans_dir = project_dir / "_docs" / "plans"

    # Get GitHub URL from .env file
    github_url = read_env_value("GITHUB_URL")

    # Get project name from directory
    project_name = project_dir.name

    result = {
        "project_name": project_name,
        "github_url": github_url,
        "plans": [],
        "errors": [],
    }

    status_dirs = ["drafts", "approved", "completed"]

    for status in status_dirs:
        subdir = plans_dir / status
        if subdir.exists() and subdir.is_dir():
            for file in subdir.iterdir():
                if file.is_file():
                    try:
                        content = file.read_text()
                        result["plans"].append(
                            {
                                "file_path": str(file),
                                "filename": file.name,
                                "status": status,
                                "content": content,
                            }
                        )
                    except Exception as e:
                        result["errors"].append(
                            {"filename": str(file), "error": str(e)}
                        )

    return result


class HTTPMethod(StrEnum):
    POST = "POST"
    GET = "GET"


def runner(
    endpoint: str,
    payload: dict,
    http_method: HTTPMethod,
) -> dict:
    base_url = read_env_value("BASE_API_URL") + ":" + read_env_value("PORT")
    url = base_url + endpoint

    try:
        if http_method is HTTPMethod.POST:
            response = requests.post(
                url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=20,
            )
        elif http_method is HTTPMethod.GET:
            response = requests.get(
                url,
                timeout=20,
            )
        else:
            raise ValueError(f"Unsupported HTTP method: {http_method}")

        # Raise an exception for bad status codes
        response.raise_for_status()

        # Return JSON response
        return response.json()

    except Timeout:
        logger.error(f"Request timed out for {url}")
        raise RuntimeError(f"Request to {endpoint} timed out after 20 seconds")

    except ConnectionError as e:
        logger.error(f"Connection failed for {url}: {e}")
        raise RuntimeError(f"Failed to connect to API at {endpoint}")

    except HTTPError as e:
        logger.error(f"HTTP error {response.status_code} for {url}: {e}")
        raise RuntimeError(
            f"API request failed with status {
                response.status_code}: {response.text}"
        )

    except ValueError as e:
        # Catches JSON decode errors and unsupported method errors
        logger.error(f"Value error for {url}: {e}")
        raise

    except RequestException as e:
        # Catch-all for other requests exceptions
        logger.error(f"Request failed for {url}: {e}")
        raise RuntimeError(f"API request to {endpoint} failed: {str(e)}")

    except Exception as e:
        # Unexpected errors
        logger.error(f"Unexpected error for {url}: {e}")
        raise RuntimeError(f"Unexpected error calling {endpoint}: {str(e)}")


def check_and_register_project(plans: dict) -> bool:
    """
    Check if project exists, register if not.

    Args:
        plans: Dictionary containing github_url and project_name

    Returns:
        bool: True if project exists or was successfully registered
    """
    endpoint = "/projects/" + plans["github_url"]

    try:
        # Try to get the project
        runner(endpoint, {}, HTTPMethod.GET)
        print(f"‚úÖ Project already exists: {plans['github_url']}")
        return True

    except RuntimeError as e:
        # Check if it's a 404 error (project not found)
        if "404" in str(e) or "not found" in str(e).lower():
            print(f"üìù Project not found, registering: {plans['github_url']}")

            # Create project object for registration
            project_data = {
                "github_url": plans["github_url"],
                "description": f"Project: {plans['project_name']}",
                "created_at": datetime.now(timezone.utc).isoformat(),
                "updated_at": datetime.now(timezone.utc).isoformat()
            }

            try:
                # Register the project
                register_endpoint = "/register/project"
                result = runner(register_endpoint,
                                project_data, HTTPMethod.POST)
                print(f"‚úÖ Successfully registered project: {result}")
                return True

            except Exception as register_error:
                print(f"‚ùå Failed to register project: {register_error}")
                return False
        else:
            # Some other error occurred
            print(f"‚ùå Error checking project: {e}")
            return False

    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return False


def main():
    print("Loading plans from disk...")

    # Ensure plan directories exist before loading
    if not plans_check_dirs():
        print("‚ùå Failed to ensure plan directories exist")
        return 1

    # Ensure command directories exist as well
    if not cmd_check_dirs():
        print("‚ùå Failed to ensure command directories exist")
        return 1

    plans_json = load_plans_from_disk()
    plan_count = len(plans_json["plans"])
    error_count = len(plans_json["errors"])

    print(f"Found: {plan_count} plans")

    # Check for loading errors first
    if error_count > 0:
        print(f"\n‚ùå Found {error_count} file loading errors:")
        for error in plans_json["errors"]:
            print(f"  - {error['filename']}: {error['error']}")
        print("\n‚ö†Ô∏è  Aborting: Please fix errors before pushing to API")
        return 1

    if plan_count == 0:
        print("No plans found to push to API...")
        return 0

    # Check and register project if needed
    if not check_and_register_project(plans_json):
        print("‚ùå Failed to ensure project is registered")
        return 1

    print(f"Pushing {plan_count} plans to API >>>")

    result = runner("/load/plans/", plans_json, HTTPMethod.POST)

    # Display results
    if result["success"]:
        print(f"Successfully saved all {len(result['results'])} plans")
        return 0
    else:
        print(f"‚ö†Ô∏è Saved with {result['failed_count']} failures")
        for error in result["errors"]:
            print(f"  ‚ùå {error}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
